bc"]]
  , ["[]", [], { null: true }, ["a"]]
  , ["[abc", [], { null: true }, ["["]]

  , "nocase tests"
  , ["XYZ", ["xYz"], { nocase: true, null: true }
    , ["xYz", "ABC", "IjK"]]
  , ["ab*", ["ABC"], { nocase: true, null: true }
    , ["xYz", "ABC", "IjK"]]
  , ["[ia]?[ck]", ["ABC", "IjK"], { nocase: true, null: true }
    , ["xYz", "ABC", "IjK"]]

  // [ pattern, [matches], MM opts, files, TAP opts]
  , "onestar/twostar"
  , ["{/*,*}", [], {null: true}, ["/asdf/asdf/asdf"]]
  , ["{/?,*}", ["/a", "bb"], {null: true}
    , ["/a", "/b/b", "/a/b/c", "bb"]]

  , "dots should not match unless requested"
  , ["**", ["a/b"], {}, ["a/b", "a/.d", ".a/.d"]]

  // .. and . can only match patterns starting with .,
  // even when options.dot is set.
  , function () {
      files = ["a/./b", "a/../b", "a/c/b", "a/.d/b"]
    }
  , ["a/*/b", ["a/c/b", "a/.d/b"], {dot: true}]
  , ["a/.*/b", ["a/./b", "a/../b", "a/.d/b"], {dot: true}]
  , ["a/*/b", ["a/c/b"], {dot:false}]
  , ["a/.*/b", ["a/./b", "a/../b", "a/.d/b"], {dot: false}]


  // this also tests that changing the options needs
  // to change the cache key, even if the pattern is
  // the same!
  , ["**", ["a/b","a/.d",".a/.d"], { dot: true }
    , [ ".a/.d", "a/.d", "a/b"]]

  , "paren sets cannot contain slashes"
  , ["*(a/b)", ["*(a/b)"], {nonull: true}, ["a/b"]]

  // brace sets trump all else.
  //
  // invalid glob pattern.  fails on bash4 and bsdglob.
  // however, in this implementation, it's easier just
  // to do the intuitive thing, and let brace-expansion
  // actually come before parsing any extglob patterns,
  // like the documentation seems to say.
  //
  // XXX: if anyone complains about this, either fix it
  // or tell them to grow up and stop complaining.
  //
  // bash/bsdglob says this:
  // , ["*(a|{b),c)}", ["*(a|{b),c)}"], {}, ["a", "ab", "ac", "ad"]]
  // but we do this instead:
  , ["*(a|{b),c)}", ["a", "ab", "ac"], {}, ["a", "ab", "ac", "ad"]]

  // test partial parsing in the presence of comment/negation chars
  , ["[!a*", ["[!ab"], {}, ["[!ab", "[ab"]]
  , ["[#a*", ["[#ab"], {}, ["[#ab", "[ab"]]

  // like: {a,b|c\\,d\\\|e} except it's unclosed, so it has to be escaped.
  , ["+(a|*\\|c\\\\|d\\\\\\|e\\\\\\\\|f\\\\\\\\\\|g"
    , ["+(a|b\\|c\\\\|d\\\\|e\\\\\\\\|f\\\\\\\\|g"]
    , {}
    , ["+(a|b\\|c\\\\|d\\\\|e\\\\\\\\|f\\\\\\\\|g", "a", "b\\c"]]


  // crazy nested {,,} and *(||) tests.
  , function () {
      files = [ "a", "b", "c", "d"
              , "ab", "ac", "ad"
              , "bc", "cb"
              , "bc,d", "c,db", "c,d"
              , "d)", "(b|c", "*(b|c"
              , "b|c", "b|cc", "cb|c"
              , "x(a|b|c)", "x(a|c)"
              , "(a|b|c)", "(a|c)"]
    }
  , ["*(a|{b,c})", ["a", "b", "c", "ab", "ac"]]
  , ["{a,*(b|c,d)}", ["a","(b|c", "*(b|c", "d)"]]
  // a
  // *(b|c)
  // *(b|d)
  , ["{a,*(b|{c,d})}", ["a","b", "bc", "cb", "c", "d"]]
  , ["*(a|{b|c,c})", ["a", "b", "c", "ab", "ac", "bc", "cb"]]


  // test various flag settings.
  , [ "*(a|{b|c,c})", ["x(a|b|c)", "x(a|c)", "(a|b|c)", "(a|c)"]
    , { noext: true } ]
  , ["a?b", ["x/y/acb", "acb/"], {matchBase: true}
    , ["x/y/acb", "acb/", "acb/d/e", "x/y/acb/d"] ]
  , ["#*", ["#a", "#b"], {nocomment: true}, ["#a", "#b", "c#d"]]


  // begin channelling Boole and deMorgan...
  , "negation tests"
  , function () {
      files = ["d", "e", "!ab", "!abc", "a!b", "\\!a"]
    }

  // anything that is NOT a* matches.
  , ["!a*", ["\\!a", "d", "e", "!ab", "!abc"]]

  // anything that IS !a* matches.
  , ["!a*", ["!ab", "!abc"], {nonegate: true}]

  // anything that IS a* matches
  , ["!!a*", ["a!b"]]

  // anything that is NOT !a* matches
  , ["!\\!a*", ["a!b", "d", "e", "\\!a"]]

  // negation nestled within a pattern
  , function () {
      files = [ "foo.js"
              , "foo.bar"
              // can't match this one without negative lookbehind.
              , "foo.js.js"
             